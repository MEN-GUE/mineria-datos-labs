---
title: "lab-01"
author: ""
date: "2026-02-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

# Laboratorio 1: Análisis Exploratorio (CineVision Studios)

## Cargar datos

```{r}
# Librerías base para carga y manipulación
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(knitr)

# Cargar dataset
# Ajuste la ruta si su estructura de carpetas es distinta
data <- read.csv("./data/movies_2026.csv")
```

---

# 1. Exploración rápida (resumen del dataset)

**Enunciado:** Haga una exploración rápida de sus datos, para eso haga un resumen de su conjunto de datos.

```{r}
summary(data)
```

---

# 2. Tipo de cada variable

**Enunciado:** Diga el tipo de cada una de las variables (cualitativa ordinal o nominal, cuantitativa continua, cuantitativa discreta).

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(knitr)

types_tbl <- tibble::tribble(
  ~variable, ~tipo, ~descripcion,
  "id", "Cualitativa nominal", "Identificador; numérico pero no mide magnitud",
  "popularity", "Cuantitativa continua", "Índice (escala continua)",
  "budget", "Cuantitativa continua", "Presupuesto (moneda)",
  "revenue", "Cuantitativa continua", "Ingresos (moneda)",
  "originalTitle", "Cualitativa nominal", "Texto",
  "originalLanguage", "Cualitativa nominal", "Código de idioma",
  "title", "Cualitativa nominal", "Texto (título en inglés)",
  "homePage", "Cualitativa nominal", "URL (alta cardinalidad, muchos NA)",
  "video", "Cualitativa nominal", "Binaria (sí/no)",
  "director", "Cualitativa nominal", "Nombre (alta cardinalidad)",
  "runtime", "Cuantitativa continua", "Duración (minutos; medida de tiempo)",
  "genres", "Cualitativa nominal", "Multi-etiqueta (separada por coma o '|')",
  "genresAmount", "Cuantitativa discreta", "Conteo de géneros",
  "productionCompany", "Cualitativa nominal", "Texto / multi-etiqueta (según fuente)",
  "productionCoAmount", "Cuantitativa discreta", "Conteo de compañías productoras",
  "productionCompanyCountry", "Cualitativa nominal", "Multi-etiqueta (códigos de país)",
  "productionCountry", "Cualitativa nominal", "Multi-etiqueta (códigos de país)",
  "productionCountriesAmount", "Cuantitativa discreta", "Conteo de países",
  "releaseDate", "Cualitativa ordinal", "Fecha (tiene orden temporal)",
  "voteCount", "Cuantitativa discreta", "Conteo de votos",
  "voteAvg", "Cuantitativa continua", "Promedio (0–10)",
  "actors", "Cualitativa nominal", "Lista de actores (texto, separada por coma o '|')",
  "actorsPopularity", "Cuantitativa continua", "Popularidad del elenco (numérica o derivable)",
  "actorsCharacter", "Cualitativa nominal", "Lista de personajes (texto)",
  "actorsAmount", "Cuantitativa discreta", "Conteo de actores",
  "castWomenAmount", "Cuantitativa discreta", "Conteo de actrices",
  "castMenAmount", "Cuantitativa discreta", "Conteo de actores",
  "releaseYear", "Cuantitativa discreta", "Año"
)

kable(types_tbl)
```

---

# 3. Normalidad en variables cuantitativas y tabla de frecuencias de cualitativas

**Enunciado:** Investigue si las variables cuantitativas siguen una distribución normal y haga una tabla de frecuencias de las variables cualitativas. Explique todos los resultados.

> Nota: con muestras muy grandes, pruebas como Shapiro-Wilk tienden a rechazar normalidad por desviaciones pequeñas.  
> Por eso se evalúa sobre una muestra aleatoria y se apoya con gráficos.

```{r}
# Librerías (si se agregan otras, colóquelas aquí)


# Separar variables numéricas y cualitativas
num_cols <- names(data)[sapply(data, is.numeric)]
cat_cols <- names(data)[sapply(data, function(x) is.character(x) || is.factor(x) || is.logical(x))]

# Tomar muestra para pruebas (si el dataset es grande)
set.seed(123)
n_sample <- min(5000, nrow(data))
data_s <- data[sample(seq_len(nrow(data)), n_sample), , drop = FALSE]

# Prueba Shapiro-Wilk en variables numéricas (con manejo de NA)
shapiro_res <- lapply(num_cols, function(col){
  x <- data_s[[col]]
  x <- x[is.finite(x)]
  # Shapiro requiere al menos 3 y máximo 5000 observaciones
  if(length(x) < 3) return(data.frame(variable=col, n=length(x), p_value=NA))
  if(length(x) > 5000) x <- sample(x, 5000)
  p <- tryCatch(shapiro.test(x)$p.value, error = function(e) NA)
  data.frame(variable=col, n=length(x), p_value=p)
}) %>% bind_rows() %>% arrange(p_value)

kable(shapiro_res, digits = 6, caption = "Prueba Shapiro-Wilk (muestra) para variables numéricas")
```

```{r}
# Histogramas (visión rápida) para algunas numéricas clave
library(ggplot2)

num_preview <- intersect(num_cols, c("popularity","budget","revenue","runtime","voteCount","voteAvg","actorsAmount","actorsPopularity"))
num_preview <- if(length(num_preview) == 0) head(num_cols, 6) else num_preview

for(col in num_preview){
  p <- ggplot(data, aes(x = .data[[col]])) +
    geom_histogram(bins = 40) +
    labs(title = paste("Histograma:", col), x = col, y = "Frecuencia")
  print(p)
}
```

```{r}
# Tabla de frecuencias para cualitativas (top 15 categorías por variable)
library(dplyr)
library(stringr)
library(knitr)

freq_tables <- lapply(cat_cols, function(col){
  x <- data[[col]]
  x <- if(is.logical(x)) as.character(x) else x
  tbl <- as.data.frame(table(x, useNA = "ifany"), stringsAsFactors = FALSE)
  names(tbl) <- c("categoria", "frecuencia")
  tbl <- tbl %>%
    arrange(desc(frecuencia)) %>%
    mutate(variable = col) %>%
    slice_head(n = 15)
  tbl
}) %>% bind_rows()

kable(freq_tables, caption = "Top 15 frecuencias por variable cualitativa (incluye NA)")
```

---

# 4. Preguntas de negocio

## 4.1 ¿Cuáles son las 10 películas que contaron con más presupuesto?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)

top10_budget <- data %>%
  arrange(desc(budget)) %>%
  select(title, budget, releaseYear, director) %>%
  slice_head(n = 10)

top10_budget
```

## 4.2 ¿Cuáles son las 10 películas que más ingresos tuvieron?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)

top10_revenue <- data %>%
  arrange(desc(revenue)) %>%
  select(title, revenue, budget, releaseYear, director) %>%
  slice_head(n = 10)

top10_revenue
```

## 4.3 ¿Cuál es la película que más votos tuvo?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)


pelicula_mas_votada <- data[which.max(data$voteCount), ]
pelicula_mas_votada[, c("title", "voteCount", "voteAvg")]
```

## 4.4 ¿Cuál es la peor película de acuerdo a los votos de todos los usuarios?

> Se interpreta como la película con menor **voteAvg**.  
> Para evitar casos con muy pocos votos (p.ej. 1 voto), se muestra también el peor caso considerando un umbral de votos.

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)

# Peor por voteAvg (sin filtrar)
worst_voteAvg <- data %>%
  filter(!is.na(voteAvg)) %>%
  arrange(voteAvg, desc(voteCount)) %>%
  select(title, voteAvg, voteCount) %>%
  slice_head(n = 1)

# Peor con umbral de votos
umbral_votos <- quantile(data$voteCount, 0.90, na.rm = TRUE) # mismo criterio usado después
worst_voteAvg_confiable <- data %>%
  filter(!is.na(voteAvg), voteCount >= umbral_votos) %>%
  arrange(voteAvg, desc(voteCount)) %>%
  select(title, voteAvg, voteCount) %>%
  slice_head(n = 1)

list(
  peor_sin_filtro = worst_voteAvg,
  peor_con_umbral = worst_voteAvg_confiable
)
```

## 4.5 ¿Cuántas películas se hicieron en cada año? ¿En qué año se hicieron más películas? (gráfico de barras)

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

movies_per_year <- data %>%
  filter(!is.na(releaseYear)) %>%
  count(releaseYear, name = "peliculas") %>%
  arrange(desc(peliculas))

anio_max <- movies_per_year$releaseYear[1]
max_count <- movies_per_year$peliculas[1]

movies_per_year %>% head(10)
```

```{r}
ggplot(movies_per_year, aes(x = factor(releaseYear), y = peliculas)) +
  geom_col() +
  labs(
    title = paste0("Películas por año (máximo en ", anio_max, " con ", max_count, " películas)"),
    x = "Año",
    y = "Cantidad de películas"
  ) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

## 4.6 Género principal de las 20 películas más recientes, género predominante y género de películas más largas

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(stringr)
library(ggplot2)

# Normalizar releaseDate
data$releaseDate <- as.Date(data$releaseDate)

# Función para extraer "género principal" como la primera etiqueta
get_main_genre <- function(x){
  if(is.na(x) || x == "") return(NA_character_)
  # separador puede ser ',' o '|'
  parts <- str_split(x, pattern = "\\s*[\\,\\|]\\s*", simplify = FALSE)[[1]]
  if(length(parts) == 0) return(NA_character_)
  str_trim(parts[1])
}

data$main_genre <- vapply(as.character(data$genres), get_main_genre, character(1))

# 20 películas más recientes
recent_movies <- data %>%
  arrange(desc(releaseDate)) %>%
  slice_head(n = 20) %>%
  select(title, releaseDate, main_genre)

recent_movies
```

```{r}
# Género principal de las 20 más recientes (conteo)
recent_genre_count <- recent_movies %>% count(main_genre, sort = TRUE)
recent_genre_count
```

```{r}
# Género predominante en todo el dataset
overall_genre_count <- data %>%
  count(main_genre, sort = TRUE)

overall_genre_count %>% head(15)
```

```{r}
# Gráfico del Top 15 géneros principales en el dataset
top15 <- overall_genre_count %>% slice_head(n = 15)

ggplot(top15, aes(x = reorder(main_genre, n), y = n)) +
  geom_col() +
  coord_flip() +
  labs(title = "Top 15 géneros principales (dataset completo)", x = "Género principal", y = "Cantidad")
```

```{r}
# ¿A qué género principal pertenecen las películas más largas?
longest_movies <- data %>%
  filter(!is.na(runtime), runtime > 0) %>%
  arrange(desc(runtime)) %>%
  slice_head(n = 20) %>%
  select(title, runtime, main_genre, releaseYear)

longest_movies
```

```{r}
# Resumen: género más frecuente entre las 20 más largas
longest_genre_summary <- longest_movies %>% count(main_genre, sort = TRUE)
longest_genre_summary
```

## 4.7 ¿Las películas de qué género principal obtuvieron mayores ganancias?

> Se calcula **ganancia** como `revenue - budget` para películas con ambos valores positivos.

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

data_profit <- data %>% filter(budget > 0, revenue > 0, !is.na(main_genre))
data_profit <- data_profit %>% mutate(profit = revenue - budget)

profit_by_genre <- data_profit %>%
  group_by(main_genre) %>%
  summarise(
    peliculas = n(),
    ganancia_total = sum(profit, na.rm = TRUE),
    ganancia_promedio = mean(profit, na.rm = TRUE)
  ) %>%
  arrange(desc(ganancia_total))

profit_by_genre %>% head(15)
```

```{r}
top10_profit <- profit_by_genre %>% slice_head(n = 10)

ggplot(top10_profit, aes(x = reorder(main_genre, ganancia_total), y = ganancia_total)) +
  geom_col() +
  coord_flip() +
  labs(title = "Top 10 géneros por ganancia total (revenue - budget)", x = "Género principal", y = "Ganancia total")
```

## 4.8 ¿La cantidad de actores influye en los ingresos? ¿Se han hecho películas con más actores en los últimos años?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

data_cast <- data %>% filter(actorsAmount > 0, revenue > 0)

# Correlación (Spearman por asimetría típica de revenue)
corr_actors_revenue <- cor(data_cast$actorsAmount, data_cast$revenue, method = "spearman", use = "complete.obs")
corr_actors_revenue
```

```{r}
ggplot(data_cast, aes(x = actorsAmount, y = revenue)) +
  geom_point(alpha = 0.3) +
  scale_y_log10() +
  labs(title = "Actores vs Revenue (escala log)", x = "Cantidad de actores", y = "Revenue (log10)")
```

```{r}
# Tendencia temporal: actores promedio por año
actors_by_year <- data %>%
  filter(!is.na(releaseYear), actorsAmount > 0) %>%
  group_by(releaseYear) %>%
  summarise(actores_prom = mean(actorsAmount, na.rm = TRUE), peliculas = n()) %>%
  arrange(releaseYear)

actors_by_year %>% tail(10)
```

```{r}
ggplot(actors_by_year, aes(x = releaseYear, y = actores_prom)) +
  geom_line() +
  geom_point() +
  labs(title = "Promedio de actores por año", x = "Año", y = "Actores promedio")
```

## 4.9 ¿La cantidad de hombres y mujeres en el reparto influye en la popularidad y los ingresos?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

data_gender <- data %>%
  filter((castWomenAmount + castMenAmount) > 0) %>%
  mutate(
    total_cast = castWomenAmount + castMenAmount,
    prop_mujeres = castWomenAmount / total_cast
  )

corr_prop_pop <- cor(data_gender$prop_mujeres, data_gender$popularity, method = "spearman", use = "complete.obs")
corr_prop_rev <- cor(data_gender$prop_mujeres, data_gender$revenue, method = "spearman", use = "complete.obs")

list(corr_prop_mujeres_popularity = corr_prop_pop,
     corr_prop_mujeres_revenue = corr_prop_rev)
```

```{r}
# Popularidad vs proporción de mujeres
ggplot(data_gender, aes(x = prop_mujeres, y = popularity)) +
  geom_point(alpha = 0.25) +
  labs(title = "Proporción de mujeres en el elenco vs Popularidad", x = "Proporción mujeres", y = "Popularidad")
```

```{r}
# Revenue vs proporción de mujeres (solo revenue > 0)
ggplot(filter(data_gender, revenue > 0), aes(x = prop_mujeres, y = revenue)) +
  geom_point(alpha = 0.25) +
  scale_y_log10() +
  labs(title = "Proporción de mujeres en el elenco vs Revenue (log)", x = "Proporción mujeres", y = "Revenue (log10)")
```

## 4.10 ¿Quiénes son los directores que hicieron las 20 películas mejor calificadas?

> Para hacerlo más robusto, se filtra al 10% de películas con más votos y luego se ordena por **voteAvg** y **voteCount**.

```{r}
# Librerías (si se agregan otras, colóquelas aquí)


umbral <- quantile(data$voteCount, 0.90, na.rm = TRUE) # 10% con más votos
data_filtrada <- subset(data, voteCount >= umbral)

top20_reales <- data_filtrada[order(-data_filtrada$voteAvg, -data_filtrada$voteCount), ][1:20, 
  c("director", "title", "voteCount", "voteAvg")]

top20_reales
```

## 4.11 ¿Cómo se correlacionan los presupuestos con los ingresos? (histograma y dispersión)

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

fin <- data %>% filter(budget > 0, revenue > 0)

corr_budget_rev <- cor(fin$budget, fin$revenue, method = "spearman", use = "complete.obs")
corr_budget_rev
```

```{r}
ggplot(fin, aes(x = budget)) +
  geom_histogram(bins = 50) +
  scale_x_log10() +
  labs(title = "Distribución de presupuesto (log10)", x = "Budget (log10)", y = "Frecuencia")
```

```{r}
ggplot(fin, aes(x = revenue)) +
  geom_histogram(bins = 50) +
  scale_x_log10() +
  labs(title = "Distribución de ingresos (log10)", x = "Revenue (log10)", y = "Frecuencia")
```

```{r}
ggplot(fin, aes(x = budget, y = revenue)) +
  geom_point(alpha = 0.25) +
  scale_x_log10() +
  scale_y_log10() +
  labs(title = "Budget vs Revenue (log-log)", x = "Budget (log10)", y = "Revenue (log10)")
```

## 4.12 ¿Se asocian ciertos meses de lanzamiento con mejores ingresos?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

data$releaseDate <- as.Date(data$releaseDate)
data$releaseMonth <- as.integer(format(data$releaseDate, "%m"))

month_rev <- data %>%
  filter(revenue > 0, !is.na(releaseMonth)) %>%
  mutate(month = factor(releaseMonth, levels = 1:12)) 

ggplot(month_rev, aes(x = month, y = revenue)) +
  geom_boxplot() +
  scale_y_log10() +
  labs(title = "Revenue por mes de lanzamiento (log)", x = "Mes", y = "Revenue (log10)")
```

```{r}
# Comparación simple de medias por mes
rev_by_month <- month_rev %>%
  group_by(releaseMonth) %>%
  summarise(
    peliculas = n(),
    revenue_prom = mean(revenue, na.rm = TRUE),
    revenue_mediana = median(revenue, na.rm = TRUE)
  ) %>%
  arrange(desc(revenue_prom))

rev_by_month
```

## 4.13 ¿En qué meses se han visto los lanzamientos con mejores ingresos? ¿Cuántas películas, en promedio, se han lanzado por mes?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)

data$releaseDate <- as.Date(data$releaseDate)
data$Mes <- as.integer(format(data$releaseDate, "%m"))

# Ingresos totales por mes
ingresos_por_mes <- data %>%
  filter(!is.na(Mes)) %>%
  group_by(Mes) %>%
  summarise(revenue_total = sum(revenue, na.rm = TRUE),
            revenue_prom = mean(revenue, na.rm = TRUE),
            peliculas = n()) %>%
  arrange(desc(revenue_total))

ingresos_por_mes
```

```{r}
# Gráfico ingresos totales por mes
library(ggplot2)

ggplot(ingresos_por_mes, aes(x = factor(Mes), y = revenue_total)) +
  geom_col() +
  labs(title = "Ingresos totales por mes", x = "Mes", y = "Revenue total")
```

```{r}
# Promedio de películas lanzadas por mes (en el dataset)
prom_peliculas_mes <- mean(ingresos_por_mes$peliculas, na.rm = TRUE)
prom_peliculas_mes
```

## 4.14 ¿Cómo se correlacionan las calificaciones con el éxito comercial?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

rate_rev <- data %>% filter(voteAvg > 0, revenue > 0)

corr_voteavg_rev <- cor(rate_rev$voteAvg, rate_rev$revenue, method = "spearman", use = "complete.obs")
corr_voteavg_rev
```

```{r}
ggplot(rate_rev, aes(x = voteAvg, y = revenue)) +
  geom_point(alpha = 0.25) +
  scale_y_log10() +
  labs(title = "VoteAvg vs Revenue (log)", x = "Calificación promedio (voteAvg)", y = "Revenue (log10)")
```

```{r}
# Calificación por bins para ver tendencia general
rate_bins <- rate_rev %>%
  mutate(bin = cut(voteAvg, breaks = c(0,4,6,7,8,10), include.lowest = TRUE)) %>%
  group_by(bin) %>%
  summarise(revenue_mediana = median(revenue, na.rm = TRUE),
            peliculas = n()) %>%
  arrange(bin)

rate_bins
```

```{r}
ggplot(rate_bins, aes(x = bin, y = revenue_mediana)) +
  geom_col() +
  scale_y_log10() +
  labs(title = "Mediana de revenue por rango de calificación", x = "Rango voteAvg", y = "Revenue mediana (log10)")
```

## 4.15 ¿Qué estrategias de marketing, como videos promocionales o páginas oficiales, generan mejores resultados?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

data <- data %>%
  mutate(
    has_homepage = ifelse(!is.na(homePage) & homePage != "", "Con Web", "Sin Web"),
    has_video = ifelse(!is.na(video) & video == TRUE, "Con Video", "Sin Video")
  )

marketing <- data %>%
  filter(revenue > 0) %>%
  group_by(has_homepage, has_video) %>%
  summarise(
    peliculas = n(),
    revenue_prom = mean(revenue, na.rm = TRUE),
    popularity_prom = mean(popularity, na.rm = TRUE)
  ) %>%
  arrange(desc(revenue_prom))

marketing
```

```{r}
# Boxplot por presencia de video
ggplot(filter(data, revenue > 0), aes(x = has_video, y = revenue)) +
  geom_boxplot() +
  scale_y_log10() +
  labs(title = "Revenue según presencia de video (log)", x = "Video", y = "Revenue (log10)")
```

```{r}
# Boxplot por presencia de web oficial
ggplot(filter(data, revenue > 0), aes(x = has_homepage, y = revenue)) +
  geom_boxplot() +
  scale_y_log10() +
  labs(title = "Revenue según presencia de página oficial (log)", x = "Página oficial", y = "Revenue (log10)")
```

## 4.16 ¿La popularidad del elenco está directamente correlacionada con el éxito de taquilla?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

cast_pop <- data %>%
  filter(!is.na(actorsPopularity), revenue > 0) %>%
  mutate(
    actorsPopularity_mean = sapply(
      actorsPopularity,
      function(x) mean(as.numeric(x), na.rm = TRUE)
    )
  ) %>%
  filter(!is.na(actorsPopularity_mean))

# Correlación de Spearman
corr_castpop_rev <- cor(
  cast_pop$actorsPopularity_mean,
  cast_pop$revenue,
  method = "spearman",
  use = "complete.obs"
)

corr_castpop_rev

# Gráfica: Popularidad promedio del elenco vs Ingresos
ggplot(cast_pop, aes(x = actorsPopularity_mean, y = revenue)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(
    title = "Popularidad promedio del elenco vs Ingresos de taquilla",
    x = "Popularidad promedio del elenco",
    y = "Ingresos de taquilla"
  ) +
  theme_minimal()
```

```{r}
ggplot(cast_pop, aes(x = actorsPopularity, y = revenue)) +
  geom_point(alpha = 0.25) +
  scale_y_log10() +
  labs(title = "Popularidad del elenco vs Revenue (log)", x = "ActorsPopularity", y = "Revenue (log10)")
```

---

# 5. Preguntas extra (10 puntos)

> Se proponen seis preguntas adicionales (distintas a las anteriores) y se responden con análisis y gráficos.

## Extra 1: ¿Es posible agrupar las películas en categorías financieras basándose en presupuesto e ingresos?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(cluster)
library(factoextra)

data_fin <- subset(data, budget > 0 & revenue > 0)
datos_escalados <- scale(data_fin[, c("budget", "revenue")])

set.seed(123)
km_fin <- kmeans(datos_escalados, centers = 3, nstart = 25)

fviz_cluster(km_fin, data = datos_escalados,
             geom = "point",
             ellipse.type = "convex",
             ggtheme = theme_minimal(),
             main = "Clustering: Presupuesto vs Ingresos")

aggregate(data_fin[, c("budget", "revenue")], by=list(cluster=km_fin$cluster), mean)
```

## Extra 2: ¿Existen grupos de películas "de culto" (alta calificación, baja popularidad) vs "virales"?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(factoextra)

data_vote <- subset(data, voteCount > 50 & voteAvg > 0)
datos_vote_esc <- scale(data_vote[, c("voteAvg", "popularity")])

set.seed(123)
km_vote <- kmeans(datos_vote_esc, centers = 3, nstart = 25)

fviz_cluster(km_vote, data = datos_vote_esc,
             geom = "point",
             main = "Clustering: Calificación vs Popularidad")

aggregate(data_vote[, c("voteAvg", "popularity")], by=list(cluster=km_vote$cluster), mean)
```

## Extra 3: ¿Cuáles son las películas más rentables en términos relativos (ROI)?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)

data_roi <- subset(data, budget > 1000000 & revenue > 0)
data_roi$ROI <- (data_roi$revenue - data_roi$budget) / data_roi$budget

top_roi <- data_roi[order(-data_roi$ROI), c("title", "budget", "revenue", "ROI")][1:10, ]
top_roi
```

## Extra 4: ¿Las coproducciones (varios países) generan más ingresos promedio?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(ggplot2)

data$es_coproduccion <- ifelse(data$productionCountriesAmount > 1, "Si", "No")

aggregate(revenue ~ es_coproduccion, data = subset(data, revenue > 0), FUN = mean)

ggplot(subset(data, revenue > 0), aes(x = es_coproduccion, y = revenue)) +
  geom_boxplot() + scale_y_log10() +
  labs(title = "Ingresos: Producción nacional vs Coproducción", y = "Revenue (log)")
```

## Extra 5: ¿Existe una duración (runtime) "ideal" que maximice la calificación promedio?

```{r}
# Librerías (si se agregan otras, colóquelas aquí)


data$rango_duracion <- cut(data$runtime,
                           breaks = c(0, 90, 120, 150, 300),
                           labels = c("<90 min", "90-120 min", "120-150 min", ">150 min"))

calif_duracion <- aggregate(voteAvg ~ rango_duracion, data = data, FUN = mean)
calif_duracion
```

```{r}
barplot(calif_duracion$voteAvg, names.arg = calif_duracion$rango_duracion,
        main = "Calificación promedio según duración", ylim = c(0, 10))
```

## Extra 6: ¿Se pueden identificar grupos según presupuesto y calificación? (¿El dinero compra buenas críticas?)

```{r}
# Librerías (si se agregan otras, colóquelas aquí)
library(dplyr)
library(factoextra)

data_calidad <- subset(data, budget > 0 & voteAvg > 0)
datos_scale <- scale(data_calidad[, c("budget", "voteAvg")])

set.seed(123)
km_calidad <- kmeans(datos_scale, centers = 3, nstart = 25)

fviz_cluster(km_calidad, data = datos_scale,
             geom = "point",
             ellipse.type = "convex",
             main = "Clustering: Presupuesto vs Calificación",
             xlab = "Presupuesto (Estandarizado)",
             ylab = "Calificación (Estandarizada)")

aggregate(data_calidad[, c("budget", "voteAvg")], by=list(cluster=km_calidad$cluster), mean)
```
