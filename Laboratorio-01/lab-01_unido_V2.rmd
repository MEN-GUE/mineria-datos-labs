---
title: "lab-01_unido_V2"
output: html_document
date: "2026-02-06"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

## Carga y preparación de datos

```{r data_load}
movies <- read.csv("./data/movies_2026.csv", stringsAsFactors = FALSE)

if (!"voteCount" %in% names(movies) && "votecount" %in% names(movies)) movies$voteCount <- movies$votecount
if (!"voteAvg" %in% names(movies) && "voteavg" %in% names(movies)) movies$voteAvg <- movies$voteavg
if (!"releaseDate" %in% names(movies) && "releasedate" %in% names(movies)) movies$releaseDate <- movies$releasedate
if (!"homePage" %in% names(movies) && "homepage" %in% names(movies)) movies$homePage <- movies$homepage
if (!"productionCountriesAmount" %in% names(movies) && "productioncountriesamount" %in% names(movies)) movies$productionCountriesAmount <- movies$productioncountriesamount
if (!"castWomenAmount" %in% names(movies) && "castwomenamount" %in% names(movies)) movies$castWomenAmount <- movies$castwomenamount
if (!"castMenAmount" %in% names(movies) && "castmenamount" %in% names(movies)) movies$castMenAmount <- movies$castmenamount
if (!"actorsPopularity" %in% names(movies) && "actorspopularity" %in% names(movies)) movies$actorsPopularity <- movies$actorspopularity
```

---

## 1 Resumen general del dataset

```{r q1_libs}
library(dplyr)

```

```{r q1}
summary(movies)
```

**Análisis:** El resumen permite ver la distribución básica de cada variable, sus rangos y si existen valores faltantes. Esto ayuda a detectar rápidamente columnas con muchos `NA` o escalas muy distintas entre variables. Con esta vista inicial se decide qué variables requieren limpieza o transformación antes de analizar. También sirve para ubicar posibles outliers por valores máximos inusuales.

---

## 2 Tipo de variable por columna

```{r q2_libs}
library(tibble)
library(knitr)

```

```{r q2}
types_tbl <- tribble(
  ~variable, ~tipo, ~descripcion,
  "id", "Cualitativa nominal", "Identificador; numérico pero no mide magnitud",
  "popularity", "Cuantitativa continua", "Índice (escala continua)",
  "budget", "Cuantitativa continua", "Presupuesto (moneda)",
  "revenue", "Cuantitativa continua", "Ingresos (moneda)",
  "originalTitle/originaltitle", "Cualitativa nominal", "Texto",
  "originalLanguage/originallanguage", "Cualitativa nominal", "Código de idioma",
  "title", "Cualitativa nominal", "Texto",
  "homePage/homepage", "Cualitativa nominal", "URL (alta cardinalidad, muchos NA)",
  "video", "Cualitativa nominal", "Binaria (sí/no)",
  "director", "Cualitativa nominal", "Nombre (alta cardinalidad)",
  "runtime", "Cuantitativa continua", "Duración (minutos)",
  "genres", "Cualitativa nominal", "Multi-etiqueta",
  "genresAmount/genresamount", "Cuantitativa discreta", "Conteo de géneros",
  "productionCompany/productioncompany", "Cualitativa nominal", "Texto / multi-etiqueta",
  "productionCoAmount/productioncoamount", "Cuantitativa discreta", "Conteo de compañías",
  "productionCountry/productioncountry", "Cualitativa nominal", "Multi-etiqueta (códigos de país)",
  "productionCountriesAmount/productioncountriesamount", "Cuantitativa discreta", "Conteo de países",
  "releaseDate/releasedate", "Cualitativa ordinal", "Fecha (orden temporal)",
  "voteCount/votecount", "Cuantitativa discreta", "Conteo de votos",
  "voteAvg/voteavg", "Cuantitativa continua", "Promedio (0–10)",
  "actors", "Cualitativa nominal", "Lista de actores",
  "actorsPopularity/actorspopularity", "Cuantitativa continua", "Popularidad (derivable)",
  "actorsCharacter/actorscharacter", "Cualitativa nominal", "Lista de personajes",
  "actorsAmount/actorsamount", "Cuantitativa discreta", "Conteo de actores",
  "castWomenAmount/castwomenamount", "Cuantitativa discreta", "Conteo de actrices",
  "castMenAmount/castmenamount", "Cuantitativa discreta", "Conteo de actores",
  "releaseYear/releaseyear", "Cuantitativa discreta", "Año"
)

kable(types_tbl)
```

**Análisis:** Clasificar las variables ayuda a escoger el análisis correcto (por ejemplo, conteos vs. promedios vs. categorías). También evita errores comunes, como tratar un `id` como una magnitud. En variables de texto o listas (como `genres` o `actors`) normalmente conviene separar/transformar antes de resumir. Las fechas se usan como variables ordenadas para analizar tendencias por año o mes.

---

## 3 Película con mayor cantidad de votos

```{r q3_libs}
library(dplyr)

```

```{r q3}
pelicula_mas_votada <- movies %>%
  filter(!is.na(voteCount)) %>%
  slice_max(order_by = voteCount, n = 1)

pelicula_mas_votada %>% select(title, voteCount)
```

**Análisis  EstPodemos ver cuál es la película con mayor `voteCount`, lo que indica la que ha recibido más votos. Esto suele correlacionar con mayor popularidad o exposición. Es importante filtrar `NA` para evitar errores. Esta película puede ser un caso de estudio interesante para analizar su presupuesto, ingresos y calificación promedio, ya que tiene una gran participación del público.

---

## 4.1 Top 10 películas con mayor presupuesto

```{r q4_1_libs}
library(dplyr)
library(knitr)

```

```{r q4_1}
top10_budget <- movies[order(-movies$budget), ][1:10, c("title", "budget")]
top10_budget
```

**Análisis:** Aquí se listan las películas con mayor inversión declarada, lo que suele relacionarse con producciones “blockbuster”. Este listado sirve para contrastar presupuesto contra ingresos y ver si las más caras realmente recuperan su inversión. Si aparecen valores 0 o `NA`, se deben filtrar para no distorsionar el ranking. También es un buen punto de partida para detectar presupuestos atípicos.

---

## 4.4 Película con menor cantidad de votos

```{r q4_4_libs}
library(dplyr)

```

```{r q4_4}
worst_voteCount <- movies[which.min(movies$voteCount), c("title", "voteCount")]
worst_voteCount
```

**Análisis:** Esto muestra la película con menor `voteCount`, que normalmente indica baja exposición o interés del público. Es importante porque métricas como `voteAvg` pueden ser poco confiables cuando hay muy pocos votos. Esta fila puede revisarse para ver si también tiene baja popularidad o si simplemente es una película poco conocida. También ayuda a decidir un umbral mínimo de votos para análisis posteriores.

---

## 4.7 Género con mayor revenue total (suma), ordenado de mayor a menor

```{r q4_7_libs}
library(dplyr)
library(knitr)

```

```{r q4_7}
top_genres_revenue <- aggregate(revenue ~ genres, data = movies, sum)
top_genres_revenue <- top_genres_revenue[order(-top_genres_revenue$revenue), ]

knitr::kable(head(top_genres_revenue, 10), 
             col.names = c("Género", "Ganancia Total"),
             format.args = list(big.mark = ","))
```

**Análisis:** Este ranking suma el revenue por categoría `genres` tal como viene en el dataset. Sirve para ubicar qué combinaciones de géneros concentran más ingresos totales en el conjunto de datos. Si `genres` viene como lista múltiple en una sola celda, el resultado agrupa por esa cadena completa y no por género individual. Para un análisis más fino se podría separar los géneros y volver a sumar por género “atómico”.

---

## 4.10 Top 20 por mejor calificación (voteAvg) dentro del 10% con más votos

```{r q4_10_libs}
library(dplyr)
library(knitr)

```

```{r q4_10}
umbral <- quantile(movies$voteCount, 0.90, na.rm = TRUE)

top20_reales <- movies %>%
  filter(!is.na(voteCount), !is.na(voteAvg), voteCount >= umbral) %>%
  arrange(desc(voteAvg), desc(voteCount)) %>%
  select(director, title, voteCount, voteAvg) %>%
  slice_head(n = 20)

kable(top20_reales)
```

**Análisis:** Al filtrar por el 10% de películas con más votos, se priorizan títulos con calificaciones más estables. Luego se ordena por `voteAvg` y se usa `voteCount` como criterio de desempate. Esto permite obtener un top con buena aceptación y suficiente participación. La lista es útil para identificar directores recurrentes o patrones de éxito.

---

## 4.13 Ingresos totales por mes de lanzamiento (gráfico)

```{r q4_13_libs}
library(dplyr)

```

```{r q4_13}
movies$releaseDate <- as.Date(movies$releaseDate)

movies$Mes <- format(movies$releaseDate, "%m")

ingresos_por_mes <- movies %>%
  filter(!is.na(Mes)) %>%
  group_by(Mes) %>%
  summarise(revenue_total = sum(revenue, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(revenue_total))

barplot(
  ingresos_por_mes$revenue_total,
  names.arg = ingresos_por_mes$Mes,
  las = 2,
  main = "Ingresos totales por mes",
  ylab = "Revenue total",
  xlab = "Mes"
)
```

**Análisis:** La gráfica muestra qué meses concentran más ingresos acumulados según la fecha de estreno. Esto puede reflejar estacionalidad (por ejemplo, temporadas de vacaciones o estrenos grandes). Como es una suma total, los meses con más películas también pueden subir en el ranking. Si se quiere aislar el efecto del mes, conviene comparar revenue promedio por mes.

---

## 4.16 Revenue promedio según presencia de página web y video

```{r q4_16_libs}
library(dplyr)
library(knitr)

```

```{r q4_16}
movies$has_homepage <- ifelse(!is.na(movies$homePage) & movies$homePage != "", "Con Web", "Sin Web")
movies$has_video <- ifelse(!is.na(movies$video) & movies$video == TRUE, "Con Video", "Sin Video")

movies_clean <- movies %>% filter(!is.na(revenue), !is.na(budget), revenue > 0, budget > 0)

marketing_impact <- movies_clean %>%
  group_by(has_homepage, has_video) %>%
  summarise(revenue_promedio = mean(revenue, na.rm = TRUE), .groups = "drop") %>%
  mutate(revenue_millones = round(revenue_promedio / 1e6, 2)) %>%
  arrange(desc(revenue_promedio))

kable(marketing_impact)
```

**Análisis:** La tabla compara el revenue promedio según si la película tiene `homePage` y/o `video` marcado. Esto sirve como aproximación al “impacto de marketing”, aunque no prueba causalidad. Es posible que producciones grandes tengan más recursos para web/video y también más ingresos por otros motivos. Aun así, ayuda a ver si existe una señal consistente en el promedio.

---

## 6 Género principal de las 20 películas más recientes (gráfico)

```{r q6_libs}
library(dplyr)

```

```{r q6}
movies$releaseDate <- as.Date(movies$releaseDate)

recent_movies <- movies %>%
  filter(!is.na(releaseDate), !is.na(genres)) %>%
  arrange(desc(releaseDate)) %>%
  slice_head(n = 20)

recent_movies$main_genre <- sapply(strsplit(recent_movies$genres, ","), `[`, 1)

recent_genre_count <- table(recent_movies$main_genre)

barplot(
  recent_genre_count,
  las = 2,
  main = "Género principal de las 20 películas más recientes",
  ylab = "Cantidad de películas",
  xlab = "Género"
)
```

**Análisis:** Este gráfico resume qué géneros aparecen más entre las 20 películas con fecha de estreno más reciente. Es útil para identificar tendencias recientes del dataset, aunque depende de la cobertura de datos del año. Si `genres` contiene múltiples valores, aquí se usa el primero como “género principal”, lo cual es una simplificación. Para mayor precisión conviene separar todos los géneros y contar cada aparición.

---

## 6.1 Género principal de las películas más largas

```{r q6_1_libs}
library(dplyr)

```

```{r q6_1}
movies$main_genre <- ifelse(
  is.na(movies$genres),
  NA,
  sapply(strsplit(movies$genres, ","), `[`, 1)
)

max_runtime <- max(movies$runtime, na.rm = TRUE)

longest_movies <- movies %>%
  filter(runtime == max_runtime) %>%
  select(title, runtime, main_genre)

longest_movies
```

**Análisis:** Se identifica la(s) película(s) con mayor duración y su género principal. Esto ayuda a ver si las películas más largas se concentran en un tipo de género específico o si es algo disperso. Si hay empates en duración máxima, se muestran varias filas. Conviene revisar también si hay valores extremos por errores de captura.

---

## 9 Relación entre composición del elenco y popularidad/ingresos

```{r q9_libs}
library(dplyr)
library(broom)
library(knitr)
```

```{r q9}
cor_women_pop <- cor(movies$castWomenAmount, movies$popularity, use = "complete.obs")
cor_men_pop   <- cor(movies$castMenAmount, movies$popularity, use = "complete.obs")

cor_women_rev <- cor(movies$castWomenAmount, log(movies$revenue + 1), use = "complete.obs")
cor_men_rev   <- cor(movies$castMenAmount, log(movies$revenue + 1), use = "complete.obs")

model_popularity <- lm(popularity ~ castWomenAmount + castMenAmount, data = movies)
model_revenue <- lm(log(revenue + 1) ~ castWomenAmount + castMenAmount, data = movies)

tabla_cor <- tibble(
  relacion = c("Mujeres vs Popularidad", "Hombres vs Popularidad", "Mujeres vs Ingresos (log)", "Hombres vs Ingresos (log)"),
  correlacion = c(cor_women_pop, cor_men_pop, cor_women_rev, cor_men_rev)
) %>%
  mutate(correlacion = round(correlacion, 4))

kable(tabla_cor)

coef_pop <- tidy(model_popularity) %>% mutate(modelo = "Popularidad") 
coef_rev <- tidy(model_revenue) %>% mutate(modelo = "Ingresos (log)")

coef_tbl <- bind_rows(coef_pop, coef_rev) %>%
  select(modelo, term, estimate, std.error, statistic, p.value) %>%
  mutate(across(c(estimate, std.error, statistic, p.value), ~ round(.x, 4)))

kable(coef_tbl)

ajuste_tbl <- bind_rows(
  glance(model_popularity) %>% mutate(modelo = "Popularidad"),
  glance(model_revenue) %>% mutate(modelo = "Ingresos (log)")
) %>%
  select(modelo, r.squared, adj.r.squared, AIC, BIC) %>%
  mutate(across(c(r.squared, adj.r.squared, AIC, BIC), ~ round(.x, 4)))

kable(ajuste_tbl)

```

**Análisis:** Las correlaciones dan una señal rápida de asociación lineal entre el tamaño del elenco por género y la popularidad/ingresos (en log). El modelo lineal permite ver el efecto conjunto de ambas variables controlándose entre sí. Si los coeficientes no son significativos, sugiere que estas variables explican poco la variación, al menos de forma lineal. En la práctica, también podrían existir variables de confusión como presupuesto, marketing o distribución.

---

## 12 Ingreso promedio por mes de lanzamiento (gráfico)

```{r q12_libs}
library(dplyr)

```

```{r q12}
movies$releaseDate <- as.Date(movies$releaseDate)
movies$releaseMonth <- format(movies$releaseDate, "%m")

movies_clean_month <- movies %>%
  filter(!is.na(releaseMonth), !is.na(revenue), revenue > 0)

avg_revenue_month <- aggregate(revenue ~ releaseMonth, data = movies_clean_month, FUN = mean)

avg_revenue_month$releaseMonth <- factor(
  avg_revenue_month$releaseMonth,
  levels = sprintf("%02d", 1:12),
  labels = month.name
)

barplot(
  avg_revenue_month$revenue,
  names.arg = avg_revenue_month$releaseMonth,
  las = 2,
  main = "Ingresos promedio según mes de lanzamiento",
  ylab = "Ingreso promedio",
  xlab = "Mes"
)
```

**Análisis:** A diferencia de la suma total, este gráfico compara el revenue promedio por mes, lo que reduce el sesgo de “meses con más películas”. Si ciertos meses destacan consistentemente, puede indicar ventanas de estreno más favorables. Aun así, el promedio puede ser sensible a outliers (blockbusters muy grandes). Para robustez se puede usar la mediana o un gráfico de cajas por mes.

---

## 15 Popularidad del elenco vs éxito de taquilla (correlación, regresión y gráfico)

```{r q15_libs}
library(dplyr)

```

```{r q15}
movies$actorsPopularity <- as.numeric(as.character(movies$actorsPopularity))
movies$revenue <- as.numeric(as.character(movies$revenue))

movies_clean_cast <- movies %>%
  filter(!is.na(actorsPopularity), !is.na(revenue), revenue > 0)

cor_elenco_revenue <- cor(movies_clean_cast$actorsPopularity, log(movies_clean_cast$revenue + 1), use = "complete.obs")

model_cast_revenue <- lm(log(revenue + 1) ~ actorsPopularity, data = movies_clean_cast)

plot(
  movies_clean_cast$actorsPopularity,
  log(movies_clean_cast$revenue + 1),
  pch = 16,
  main = "Popularidad del elenco vs éxito de taquilla",
  xlab = "Popularidad del elenco",
  ylab = "Log(Ingresos + 1)"
)
abline(model_cast_revenue, col = "red", lwd = 2)

cat("Correlación entre popularidad del elenco e ingresos (log):\n")
cat(cor_elenco_revenue, "\n\n")

cat("Modelo lineal:\n")
print(summary(model_cast_revenue))
```

**Análisis:** La nube de puntos muestra si existe un patrón creciente entre la popularidad del elenco y los ingresos (en escala log). La correlación resume esa asociación y la regresión estima una tendencia promedio. Si la dispersión es alta, significa que la popularidad del elenco no explica por sí sola el éxito de taquilla. En ese caso, conviene agregar variables como presupuesto, género o fecha de estreno en un modelo multivariado.

---

## Preguntas extra 1 Clustering financiero (budget vs revenue)

```{r ex1_libs}
library(dplyr)
library(factoextra)

```

```{r ex1}
movies_fin <- movies %>% filter(!is.na(budget), !is.na(revenue), budget > 0, revenue > 0)

datos_escalados <- scale(movies_fin[, c("budget", "revenue")])

set.seed(123)
km_fin <- kmeans(datos_escalados, centers = 3, nstart = 25)

fviz_cluster(
  km_fin,
  data = datos_escalados,
  geom = "point",
  ellipse.type = "convex",
  main = "Clustering: Presupuesto vs Ingresos"
)

aggregate(movies_fin[, c("budget", "revenue")], by = list(cluster = km_fin$cluster), mean)
```

**Análisis:** El clustering agrupa películas según similitud en presupuesto e ingresos, creando “categorías financieras” sin etiquetas predefinidas. Las medias por cluster ayudan a interpretar cada grupo (por ejemplo, alto presupuesto/alto ingreso vs. bajo presupuesto). Como se usan datos escalados, el algoritmo no se sesga por la magnitud de una variable frente a otra. El número de clusters (3) es una decisión que puede ajustarse con métodos como codo o silhouette.

---

## Preguntas extra 2 Culto vs virales (voteAvg vs popularity)

```{r ex2_libs}
library(dplyr)
library(factoextra)

```

```{r ex2}
movies_vote <- movies %>% filter(!is.na(voteCount), !is.na(voteAvg), !is.na(popularity), voteCount > 50, voteAvg > 0)

datos_vote_esc <- scale(movies_vote[, c("voteAvg", "popularity")])

set.seed(123)
km_vote <- kmeans(datos_vote_esc, centers = 3, nstart = 25)

fviz_cluster(
  km_vote,
  data = datos_vote_esc,
  geom = "point",
  main = "Clustering: Calificación vs Popularidad"
)

aggregate(movies_vote[, c("voteAvg", "popularity")], by = list(cluster = km_vote$cluster), mean)
```

**Análisis:** Este clustering busca separar patrones como “alta calificación/baja popularidad” frente a “alta popularidad/calificación variable”. Es una forma rápida de segmentar el comportamiento sin reglas manuales. El filtro de `voteCount > 50` mejora la estabilidad de `voteAvg`. Para nombrar los clusters, se revisan las medias y se comparan con la nube de puntos.

---

## Preguntas extra 3 Top 10 por ROI

```{r ex3_libs}
library(dplyr)
library(knitr)

```

```{r ex3}
movies_roi <- movies %>% filter(!is.na(budget), !is.na(revenue), budget > 1000000, revenue > 0) %>%
  mutate(ROI = (revenue - budget) / budget) %>%
  arrange(desc(ROI)) %>%
  select(title, budget, revenue, ROI) %>%
  slice_head(n = 10)

kable(movies_roi)
```

**Análisis:** El ROI mide rentabilidad relativa, evitando la trampa de fijarse solo en revenue absoluto. Una película con ingresos modestos puede ser muy rentable si su presupuesto fue bajo. El filtro de presupuesto > 1M reduce casos extremos por “micropresupuestos” que inflan el ROI artificialmente. Este top es útil para estudiar estrategias de producción eficientes.

---

## Preguntas extra 4 Coproducción vs revenue (boxplot)

```{r ex4_libs}
library(dplyr)
library(ggplot2)

```

```{r ex4}
movies$es_coproduccion <- ifelse(movies$productionCountriesAmount > 1, "Si", "No")

aggregate(revenue ~ es_coproduccion, data = subset(movies, !is.na(revenue) & revenue > 0), FUN = mean)

ggplot(subset(movies, !is.na(revenue) & revenue > 0), aes(x = es_coproduccion, y = revenue)) +
  geom_boxplot() +
  scale_y_log10() +
  labs(title = "Ingresos: Producción nacional vs coproducción", y = "Revenue (escala log)")
```

**Análisis:** Aquí se compara si las coproducciones tienden a generar más ingresos promedio que las producciones de un solo país. El boxplot permite ver tanto la mediana como la dispersión, usando escala log para manejar valores muy grandes. Si la distribución de “Sí” está por encima de “No”, sugiere una ventaja en ingresos, aunque no necesariamente causal. Conviene revisar tamaño de muestra por grupo para no sobreinterpretar.

---

## Preguntas extra 5 Calificación promedio por rango de duración (gráfico)

```{r ex5_libs}
library(dplyr)

```

```{r ex5}
movies$rango_duracion <- cut(
  movies$runtime,
  breaks = c(0, 90, 120, 150, 300),
  labels = c("<90 min", "90-120 min", "120-150 min", ">150 min")
)

calif_duracion <- aggregate(voteAvg ~ rango_duracion, data = movies, FUN = mean)

calif_duracion

barplot(
  calif_duracion$voteAvg,
  names.arg = calif_duracion$rango_duracion,
  main = "Calificación promedio según duración",
  ylab = "voteAvg promedio",
  ylim = c(0, 10)
)
```

**Análisis:** Este análisis agrupa las películas por duración y calcula su calificación promedio. Sirve para ver si existe una “zona” donde, en promedio, las películas reciben mejores valoraciones. Como se usa promedio, grupos con pocas películas pueden ser inestables. Si se detectan diferencias claras, se puede profundizar con boxplots o pruebas estadísticas.

---

## Preguntas extra 6 Clustering calidad (budget vs voteAvg)

```{r ex6_libs}
library(dplyr)
library(factoextra)

```

```{r ex6}
movies_calidad <- movies %>% filter(!is.na(budget), !is.na(voteAvg), budget > 0, voteAvg > 0)

datos_scale <- scale(movies_calidad[, c("budget", "voteAvg")])

set.seed(123)
km_calidad <- kmeans(datos_scale, centers = 3, nstart = 25)

fviz_cluster(
  km_calidad,
  data = datos_scale,
  geom = "point",
  ellipse.type = "convex",
  main = "Clustering: Presupuesto vs Calificación"
)

aggregate(movies_calidad[, c("budget", "voteAvg")], by = list(cluster = km_calidad$cluster), mean)
```

**Análisis:** Este clustering agrupa películas por presupuesto y calificación promedio, explorando si “el dinero compra buenas críticas”. Las medias por cluster permiten interpretar si hay un grupo de alto presupuesto/alta calificación o si no existe esa relación. Como se usa k-means, se asume una estructura de clusters relativamente “redondeada” en el espacio escalado. Si los clusters se solapan mucho, es señal de que la relación es débil o no lineal.
